Do Not The Cat Protocol                                    Fart Draws
CatnIP #0000                                             January 2024


            Defining the Do Not The Cat Protocol (DNTCP)

Abstract

   "Do Not The Cat Protocol" (DNTCP) is a peer-to-peer (P2P) protocol 
   that establishes and maintains HTTP-based connections in network 
   environments with Network Address Translation (NAT) over WebRTC.
   The protocol enables communication in networks without Universal
   Plug and Play (UPnP), including those involving carrier-grade NAT.

1. Introduction

   This document proposes "Do Not The Cat Protocol" (DNTCP), a 
   peer-to-peer (P2P) networking protocol focused on enabling 
   NATed devices establish and maintain HTTP-based connections using
   WebRTC as the tunnelling method. Four main types of communication
   connections are discussed here - non-NAT-to-non-NAT [HTTP to peer], 
   NAT-to-non-NAT [ICE/RTC to peer], NAT-to-non-NAT-to-non-NAT [ICE/
   RTC to Federation to peer] and NAT-to-non-NAT-to-NAT [ICE/RTC to
   Federation to ICE/RTC to peer]. 

1.1. Terminology

   Flooding: Involves rebroadcasting messages to immediate peers to
   distribute to the network.

   Nodes: An entity involved in executing or experiencing the outcomes
   of the protocol (e.g., Sender Peer, Receiver Peer, Adjacent Peer,
   Non-NATed Routing Peer).

   Message: Information or directive transferred between actors.

2. Communication Methods

2.1. Non-NAT'ed Communication

   Involves direct HTTP requests made to the peer API over exposed 
   endpoint (e.g., /api/v1/route). Used as fallback in NAT-to-non-NAT
   and non-NAT-to-non-NAT connections.

2.2. NAT'ed Communication

   NAT'ed Bootstrapping forms an ICE/RTC relay to relay HTTP requests 
   to the peer AP. Used for all connections, but is the sole option 
   for NAT-to-non-NAT and NAT-to-NAT connections.

3. Peer Identity and Records

   Nodes maintain Peer Records, compiled as JSON packets:

   {
      "peer_name": "string",
      "unique_id": "string",
      "exposed": "boolean",
      "closest_peer": "string",
      "address": "string, optional",
      "created": "timestamp",
      "public_key": "string",
      "ttl": "number"
   }

   Peer Records aid nodes in determining the type of connection to be
   facilitated. Discovery of peers is an ongoing process, with nodes 
   frequently exchanging and updating their Peer Records.

   Each node has its own Peer Record to pass onto other peers.

3.1 Unique identity and In-Ecosystem Addressing

   To create a unique identity to use for a node's unique_id, the
   following is computed.

   * Obtain the MAC address of the network interface on the server. 
     The MAC address is a unique identifier assigned to the network 
     interface by the manufacturer.

   * Obtain the Node name of the server. The Node name can be a 
     user-defined name or a predefined name specific to your 
     application.

   * Concatenate the MAC address and the Node name to create a string
     in the format "{MAC address}|{Node name}".

   * Hash the concatenated string using a cryptographic hash function 
     like SHA-256.

   * The hashed value will serve as the unique identifier for the 
     server.

   To refer to a certain identity, the following URI formats are
   used.

   dweb://dntcp/{Unique identifier}/sub-directory
   dntcp://{unique identifier}/sub-directory

3.3 Peer Registry and Keep-alive

   Nodes can register themselves or forward other peers at
   `/api/v1/peer`, returning their own Peer Record. This gets
   propagated to other nodes via flooding, and obtain a node's peer
   list via `/api/v1/peers`.

   TTL is used to make sure each broadcast doesn't keep propagating
   infinitely.

4. Bootstrapping Routines

   Bootstrapping help establish Peer Connections over ICE/RTC.

4.1. Direct Bootstrap Routine

   Exchanges SDP Offers and Answers directly between adjacent NATed
   nodes.
   
   Using SDP Offers, it is possible to establish an RTC connection
   between two peers.

   4.1.1 Connect Offer (CO): 

   Connect Offers (COs) contain offers from a client to connect to
   a specific peer.

   This is forwarded to '/api/v1/offer'.

   {
      "source_id": "string",
      "destination_id": "string",
      "turn_server": "string",
      "sdp_offer": "SDP information",
      "poc_address": "string",
      "created": "timestamp",
      "ttl": "number"
   }

   poc_address contains either the current peer's address or the
   closest peer that can route this information to the requesting
   peer. Hence, if NAT'ed, the closest non-NAT peer is provided.

   4.1.2 Connect Response (CR):

   Connect Responses (CRs) contain responses to offers made by
   requesting peers generated by the requested peer.

   This is forwarded to '/api/v1/connect' and is part of the
   '/api/v1/offer' response body if the CO it is responding to had
   no destination_id or the responding peer is the destination. This
   is the response to a CO. Note that

   {
      "source_id": "string",
      "destination_id": "string",
      "turn_server": "string",
      "sdp_answer": "SDP information",
      "poc_address": "string",
      "created": "timestamp",
      "ttl": "number"
   }
   
   poc_address contains either the current peer's address or the
   closest peer that can route this information to the requesting
   peer. Hence, if NAT'ed, the closest non-NAT peer is provided.

4.2. Indirect Bootstrap Routine

   Used when connections are to be established between non-adjacent 
   NATed nodes, leveraging non-NATed nodes as routing intermediaries.

   This is done via forwarding.
   
   On receive COs and CRs, if they're not the destination, nodes need to
   forward COs to peers' '/api/v1/offer' and CRs to '/api/v1/connect',
   until TTL is exhausted. These are assigned to their respective source
   peer record. CRs can be expired as well.
   

5. Peer Connections

5.1 Content Message (CMs)

   Post-connection, nodes can pass payloads amongst each other to be
   parsed. These messages encapsulate the network layer payloads. The
   encapsulated data is base64 encoded HTTP packets, dictated by the
   protocol attribute.

   {
     "source_id": "string",
     "destination_id": "string",
     "protocol": "string",
     "payload": "string",
     "ttl": "number"
   }

   Packet payloads are distributed over an ICE/RTC channel for non-NAT
   targets and sources. If all adjacent peers are exposed, requests
   containing packet payloads can be made directly over an HTTP PUT
   request at '/api/v1/packet_send'. 

   If the recepient isn't the target ID, the packet is flooded across
   thenetwork, and no longer passed around if TTL is exhausted or
   target ID is reached.

5.2 Routing Content Packets

   First a node must receive the Content Packet from a peer either via
   HTTP or ICE/RTC.

   On receiving a content packet, the payload is used to populate an
   HTTP request to a port on http://[::ffff:127.0.0.1], at the node's
   local network.

   The response to this request from the local server is then relayed
   onto the peer.

5.3 ICE/RTC Connection Tracking

   Each peer need to track their ICE/RTC connections, thus each one of
   them are maintained, expiring them after 30 seconds of no activity.
   Empty packets can be used to achieve keep-alive.

6. Security Considerations

   DNTCP does not include in-built security measures. Thus, each 
   participating node is responsible for its data security.

7. Acknowledgements

   Gratitude to all who contributed to the development of DNTCP.
